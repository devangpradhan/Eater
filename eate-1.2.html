<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Snake Bet Game (PixiJS) with Glitch Effect</title>
  <style>
    html, body { margin: 0; padding: 0; background: #ffffff; width: 100vw; height: 100vh; overflow: hidden; }
    #game { display: block; margin: 0 auto; }
    #toggleBetMode {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 10;
      padding: 10px 24px;
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(90deg, #6366f1 0%, #06b6d4 100%);
      border: none;
      border-radius: 12px;
      box-shadow: 0 4px 16px #0002;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
    }
    #betCountDisplay {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10;
      padding: 10px 24px;
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(90deg, #06b6d4 0%, #6366f1 100%);
      border: none;
      border-radius: 12px;
      box-shadow: 0 4px 16px #0002;
      user-select: none;
      letter-spacing: 1px;
      transition: background 0.2s, transform 0.1s;
    }
    #toggleBetMode:hover {
      background: linear-gradient(90deg, #06b6d4 0%, #6366f1 100%);
      transform: scale(1.05);
    }
    #toggleBetMode:active {
      background: linear-gradient(90deg, #6366f1 0%, #06b6d4 100%);
      transform: scale(0.97);
    }
  </style>
</head>
<body>
  <button id="toggleBetMode">Multiple Bet: ON</button>
  <div id="betCountDisplay">Bets: 0</div>
  <!-- PixiJS v7 CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
  <!-- Pixi Glitch Filter CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@pixi/filter-glitch@4.2.2/dist/filter-glitch.min.js"></script>
  <script>
    // --- Config ---
    const BLOCK_SIZE = 28;
    const GRID_COLS = Math.floor(window.innerWidth / BLOCK_SIZE);
    const GRID_ROWS = Math.floor(window.innerHeight / BLOCK_SIZE);

    // --- PixiJS Setup ---
    const app = new PIXI.Application({
      width: GRID_COLS * BLOCK_SIZE,
      height: GRID_ROWS * BLOCK_SIZE,
      backgroundColor: 0xffffff,
      antialias: false,
      resolution: window.devicePixelRatio || 1,
    });
    document.body.appendChild(app.view);

    // --- State ---
    let snake = [{col: 5, row: 5}]; // Snake body: head is first element
    let snakeDir = {x: 1, y: 0};
    let snakeMovingToBet = false;
    let snakePausedUntil = 0;
    let cursor = {col: 0, row: 0};
    let betModeMultiple = true;
    let bets = []; // Array of {col, row, color}

    // --- Graphics Containers ---
    const gridGfx = new PIXI.Graphics();
    const snakeGfx = new PIXI.Graphics();
    const betGfx = new PIXI.Graphics();
    const cursorGfx = new PIXI.Graphics();
    app.stage.addChild(gridGfx, betGfx, snakeGfx, cursorGfx);

    // --- Glitch Filter Setup ---
    const glitchFilter = new PIXI.filters.GlitchFilter({
      slices: 5,
      offset: 10,
      direction: 0,
      fillMode: 1,
      seed: Math.random(),
    });
    let glitchTimeout = null;

    // --- Apply Glitch Effect ---
    function triggerGlitch(duration = 350) {
      snakeGfx.filters = [glitchFilter];
      if (glitchTimeout) clearTimeout(glitchTimeout);
      glitchTimeout = setTimeout(() => {
        snakeGfx.filters = null;
      }, duration);
    }

    // --- Draw Grid ---
    function drawGrid() {
      gridGfx.clear();
      gridGfx.lineStyle(1, 0xeeeeee, 0.5);
      for (let r = 0; r <= GRID_ROWS; r++) {
        gridGfx.moveTo(0, r * BLOCK_SIZE);
        gridGfx.lineTo(GRID_COLS * BLOCK_SIZE, r * BLOCK_SIZE);
      }
      for (let c = 0; c <= GRID_COLS; c++) {
        gridGfx.moveTo(c * BLOCK_SIZE, 0);
        gridGfx.lineTo(c * BLOCK_SIZE, GRID_ROWS * BLOCK_SIZE);
      }
    }

    // --- Draw Snake ---
    function drawSnake() {
      snakeGfx.clear();
      for (const [i, part] of snake.entries()) {
        snakeGfx.beginFill(0x222326);
        snakeGfx.drawRect(part.col * BLOCK_SIZE, part.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        snakeGfx.endFill();
        if (i === 0) {
          const eyeW = 3, eyeH = 8;
          const offsetX = BLOCK_SIZE / 4;
          const offsetY = BLOCK_SIZE / 3;
          // Left eye
          snakeGfx.beginFill(0xffffff);
          snakeGfx.drawRect(part.col * BLOCK_SIZE + offsetX, part.row * BLOCK_SIZE + offsetY, eyeW, eyeH);
          snakeGfx.endFill();
          // Right eye
          snakeGfx.beginFill(0xffffff);
          snakeGfx.drawRect(part.col * BLOCK_SIZE + BLOCK_SIZE - offsetX - eyeW, part.row * BLOCK_SIZE + offsetY, eyeW, eyeH);
          snakeGfx.endFill();
        }
      }
    }

    // --- Draw Bets ---
    function drawBets() {
      betGfx.clear();
      bets.forEach((bet) => {
        betGfx.beginFill(PIXI.utils.string2hex(bet.color));
        betGfx.drawRect(bet.col * BLOCK_SIZE, bet.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        betGfx.endFill();
      });
    }

    // --- Draw Cursor ---
    function drawCursor() {
      cursorGfx.clear();
      cursorGfx.lineStyle(2, 0xffffff, 1);
      cursorGfx.drawRect(cursor.col * BLOCK_SIZE, cursor.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    // --- Mouse Cursor ---
    app.view.addEventListener('mousemove', e => {
      const rect = app.view.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      cursor.col = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(x / BLOCK_SIZE)));
      cursor.row = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(y / BLOCK_SIZE)));
    });

    // --- Place Bet ---
    app.view.addEventListener('click', () => {
      if (betModeMultiple) {
        if (!bets.some(b => b.col === cursor.col && b.row === cursor.row)) {
          bets.push({
            col: cursor.col,
            row: cursor.row,
            color: getRandomColor()
          });
        }
      } else {
        bets = [{
          col: cursor.col,
          row: cursor.row,
          color: getRandomColor()
        }];
      }
      snakeMovingToBet = true;
    });

    // --- Snake Movement ---
    function moveSnake() {
      if (Date.now() < snakePausedUntil) return; // Pause after eating

      let head = snake[0];
      let next = {col: head.col, row: head.row};

      if (snakeMovingToBet && bets.length > 0) {
        // Move towards first bet in sequence
        const bet = bets[0];
        if (head.col < bet.col) next.col++;
        else if (head.col > bet.col) next.col--;
        else if (head.row < bet.row) next.row++;
        else if (head.row > bet.row) next.row--;
        // If reached bet
        if (next.col === bet.col && next.row === bet.row) {
          // Grow snake by adding a new segment at the tail
          const tail = snake[snake.length - 1];
          snake.push({col: tail.col, row: tail.row});
          bets.shift(); // Remove eaten bet
          snakeMovingToBet = bets.length > 0;
          snakePausedUntil = Date.now() + 50; // Pause 0.5s
          triggerGlitch(); // <-- Glitch effect here!
        }
      } else {
        // Random roam (no reverse, no self-collision)
        const dirs = [
          {x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}
        ];
        const last = snake[1] || head;
        let validDirs = dirs.filter(d => head.col + d.x !== last.col || head.row + d.y !== last.row);
        validDirs = validDirs.filter(d => {
          const newCol = head.col + d.x;
          const newRow = head.row + d.y;
          return !snake.some(part => part.col === newCol && part.row === newRow);
        });
        const dir = validDirs.length ? validDirs[Math.floor(Math.random() * validDirs.length)] : {x:0, y:0};
        next.col += dir.x;
        next.row += dir.y;
        next.col = Math.max(0, Math.min(GRID_COLS - 1, next.col));
        next.row = Math.max(0, Math.min(GRID_ROWS - 1, next.row));
      }

      // Move snake body
      for (let i = snake.length - 1; i > 0; i--) {
        snake[i] = {...snake[i - 1]};
      }
      snake[0] = next;
    }

    // --- Random Color Generator ---
    function getRandomColor() {
      return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
    }

    // --- Game Loop ---
    let lastMove = 0;
    app.ticker.add((delta) => {
      const now = performance.now();
      let baseSpeed = 200;
      let speed = Math.max(60, baseSpeed - bets.length * 25);
      if (now - lastMove > speed) {
        moveSnake();
        lastMove = now;
      }
      drawGrid();
      drawBets();
      drawSnake();
      drawCursor();
      document.getElementById('betCountDisplay').textContent = 'Bets: ' + bets.length;
    });

    // --- Responsive Resize ---
    function resize() {
      const cols = Math.floor(window.innerWidth / BLOCK_SIZE);
      const rows = Math.floor(window.innerHeight / BLOCK_SIZE);
      app.renderer.resize(cols * BLOCK_SIZE, rows * BLOCK_SIZE);
    }
    window.addEventListener('resize', resize);

    // Toggle bet mode button
    document.getElementById('toggleBetMode').onclick = function() {
      betModeMultiple = !betModeMultiple;
      this.textContent = betModeMultiple ? 'Multiple Bet: ON' : 'Multiple Bet: OFF';
      if (!betModeMultiple && bets.length > 1) {
        bets = bets.length ? [bets[0]] : [];
      }
    };

    // Initial draw
    resize();
    drawGrid();
    drawSnake();
    drawBets();
    drawCursor();
  </script>
</body>
</html>