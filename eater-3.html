easeljs<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Snake Bet Game (EaselJS)</title>
  <style>
    html, body { margin: 0; padding: 0; background: #18181b; width: 100vw; height: 100vh; overflow: hidden; }
    #gameCanvas { display: block; margin: 0 auto; background: #18181b; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script src="https://code.createjs.com/1.0.0/easeljs.min.js"></script>
  <script>
    // --- Config ---
    const BLOCK_SIZE = 28;
    let GRID_COLS = Math.floor(window.innerWidth / BLOCK_SIZE);
    let GRID_ROWS = Math.floor(window.innerHeight / BLOCK_SIZE);

    // --- EaselJS Setup ---
    const canvas = document.getElementById('gameCanvas');
    canvas.width = GRID_COLS * BLOCK_SIZE;
    canvas.height = GRID_ROWS * BLOCK_SIZE;
    const stage = new createjs.Stage(canvas);

    // --- State ---
    let snake = [{col: 5, row: 5}];
    let snakeDir = {x: 1, y: 0};
    let snakeMovingToBet = false;
    let snakePausedUntil = 0;
    let cursor = {col: 0, row: 0};
    let bet = null;

    // --- Graphics ---
    const gridShape = new createjs.Shape();
    const snakeShape = new createjs.Shape();
    const betShape = new createjs.Shape();
    const cursorShape = new createjs.Shape();
    stage.addChild(gridShape, betShape, snakeShape, cursorShape);

    // --- Draw Grid ---
    function drawGrid() {
      gridShape.graphics.clear();
      gridShape.graphics.setStrokeStyle(1).beginStroke("#27272a");
      for (let c = 0; c < GRID_COLS; c++) {
        for (let r = 0; r < GRID_ROWS; r++) {
          gridShape.graphics.drawRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
      gridShape.graphics.endStroke();
    }

    // --- Draw Snake ---
    function drawSnake() {
      snakeShape.graphics.clear();
      snakeShape.graphics.beginFill("#888888");
      for (const part of snake) {
        snakeShape.graphics.drawRect(part.col * BLOCK_SIZE, part.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      }
      snakeShape.graphics.endFill();
    }

    // --- Draw Bet ---
    function drawBet() {
      betShape.graphics.clear();
      if (bet) {
        betShape.graphics.beginFill(bet.color);
        betShape.graphics.drawRect(bet.col * BLOCK_SIZE, bet.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        betShape.graphics.endFill();
      }
    }

    // --- Draw Cursor ---
    function drawCursor() {
      cursorShape.graphics.clear();
      cursorShape.graphics.setStrokeStyle(2).beginStroke("#ffffff");
      cursorShape.graphics.drawRect(cursor.col * BLOCK_SIZE, cursor.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      cursorShape.graphics.endStroke();
    }

    // --- Mouse Cursor ---
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      cursor.col = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(x / BLOCK_SIZE)));
      cursor.row = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(y / BLOCK_SIZE)));
    });

    // --- Place Bet ---
    canvas.addEventListener('click', () => {
      bet = {
        col: cursor.col,
        row: cursor.row,
        color: getRandomColor()
      };
      snakeMovingToBet = true;
    });

    // --- Snake Movement ---
    function moveSnake() {
      if (Date.now() < snakePausedUntil) return;
      let head = snake[0];
      let next = {col: head.col, row: head.row};

      if (snakeMovingToBet && bet) {
        if (head.col < bet.col) next.col++;
        else if (head.col > bet.col) next.col--;
        else if (head.row < bet.row) next.row++;
        else if (head.row > bet.row) next.row--;
        if (next.col === bet.col && next.row === bet.row) {
          const tail = snake[snake.length - 1];
          snake.push({col: tail.col, row: tail.row});
          bet = null;
          snakeMovingToBet = false;
          snakePausedUntil = Date.now() + 1000;
        }
      } else {
        const dirs = [
          {x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}
        ];
        const last = snake[1] || head;
        const validDirs = dirs.filter(d => head.col + d.x !== last.col || head.row + d.y !== last.row);
        const dir = validDirs[Math.floor(Math.random() * validDirs.length)];
        next.col += dir.x;
        next.row += dir.y;
        next.col = Math.max(0, Math.min(GRID_COLS - 1, next.col));
        next.row = Math.max(0, Math.min(GRID_ROWS - 1, next.row));
      }
      for (let i = snake.length - 1; i > 0; i--) {
        snake[i] = {...snake[i - 1]};
      }
      snake[0] = next;
    }

    // --- Random Color Generator ---
    function getRandomColor() {
      // Returns a random hex color string (EaselJS accepts "#RRGGBB")
      return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
    }

    // --- Game Loop ---
    let lastMove = 0;
    createjs.Ticker.framerate = 60;
    createjs.Ticker.addEventListener("tick", () => {
      const now = performance.now();
      if (now - lastMove > 200) {
        moveSnake();
        lastMove = now;
      }
      drawGrid();
      drawBet();
      drawSnake();
      drawCursor();
      stage.update();
    });

    // --- Responsive Resize ---
    function resize() {
      GRID_COLS = Math.floor(window.innerWidth / BLOCK_SIZE);
      GRID_ROWS = Math.floor(window.innerHeight / BLOCK_SIZE);
      canvas.width = GRID_COLS * BLOCK_SIZE;
      canvas.height = GRID_ROWS * BLOCK_SIZE;
      stage.update();
    }
    window.addEventListener('resize', resize);

    // Initial draw
    resize();
    drawGrid();
    drawSnake();
    drawBet();
    drawCursor();
    stage.update();
  </script>
</body>
</html>