<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Snake Bet Game (PixiJS)</title>
  <style>
    html, body { margin: 0; padding: 0; background: #18181b; width: 100vw; height: 100vh; overflow: hidden; }
    #game { display: block; margin: 0 auto; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
  <script>
    // --- Config ---
    const BLOCK_SIZE = 28;
    const GRID_COLS = Math.floor(window.innerWidth / BLOCK_SIZE);
    const GRID_ROWS = Math.floor(window.innerHeight / BLOCK_SIZE);

    // --- PixiJS Setup ---
    const app = new PIXI.Application({
      width: GRID_COLS * BLOCK_SIZE,
      height: GRID_ROWS * BLOCK_SIZE,
      backgroundColor: 0x18181b,
      antialias: false,
      resolution: window.devicePixelRatio || 1,
    });
    document.body.appendChild(app.view);

    // --- State ---
    let snake = [{col: 5, row: 5}]; // Snake body: head is first element
    let snakeDir = {x: 1, y: 0};
    let snakeMovingToBet = false;
    let snakePausedUntil = 0;
    let cursor = {col: 0, row: 0};
    let bet = null; // {col, row, color}

    // --- Graphics Containers ---
    const gridGfx = new PIXI.Graphics();
    const snakeGfx = new PIXI.Graphics();
    const betGfx = new PIXI.Graphics();
    const cursorGfx = new PIXI.Graphics();
    app.stage.addChild(gridGfx, betGfx, snakeGfx, cursorGfx);

    // --- Draw Grid ---
    function drawGrid() {
      gridGfx.clear();
      gridGfx.lineStyle(1, 0x27272a, 1);
      for (let c = 0; c < GRID_COLS; c++) {
        for (let r = 0; r < GRID_ROWS; r++) {
          gridGfx.drawRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
    }

    // --- Draw Snake ---
    function drawSnake() {
      snakeGfx.clear();
      snakeGfx.beginFill(0x888888); // Gray color
      for (const part of snake) {
        snakeGfx.drawRect(part.col * BLOCK_SIZE, part.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      }
      snakeGfx.endFill();
    }

    // --- Draw Bet ---
    function drawBet() {
      betGfx.clear();
      if (bet) {
        betGfx.beginFill(PIXI.utils.string2hex(bet.color));
        betGfx.drawRect(bet.col * BLOCK_SIZE, bet.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        betGfx.endFill();
      }
    }

    // --- Draw Cursor ---
    function drawCursor() {
      cursorGfx.clear();
      cursorGfx.lineStyle(2, 0xffffff, 1);
      cursorGfx.drawRect(cursor.col * BLOCK_SIZE, cursor.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    // --- Mouse Cursor ---
    app.view.addEventListener('mousemove', e => {
      const rect = app.view.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      cursor.col = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(x / BLOCK_SIZE)));
      cursor.row = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(y / BLOCK_SIZE)));
    });

    // --- Place Bet ---
    app.view.addEventListener('click', () => {
      bet = {
        col: cursor.col,
        row: cursor.row,
        color: getRandomColor()
      };
      snakeMovingToBet = true;
    });

    // --- Snake Movement ---
    function moveSnake() {
      if (Date.now() < snakePausedUntil) return; // Pause after eating

      let head = snake[0];
      let next = {col: head.col, row: head.row};

      if (snakeMovingToBet && bet) {
        // Move towards bet
        if (head.col < bet.col) next.col++;
        else if (head.col > bet.col) next.col--;
        else if (head.row < bet.row) next.row++;
        else if (head.row > bet.row) next.row--;
        // If reached bet
        if (next.col === bet.col && next.row === bet.row) {
          // Grow snake by adding a new segment at the tail
          const tail = snake[snake.length - 1];
          snake.push({col: tail.col, row: tail.row});
          bet = null;
          snakeMovingToBet = false;
          snakePausedUntil = Date.now() + 1000; // Pause 1s
        }
      } else {
        // Random roam (no reverse)
        const dirs = [
          {x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}
        ];
        // Prevent reversing into itself
        const last = snake[1] || head;
        const validDirs = dirs.filter(d => head.col + d.x !== last.col || head.row + d.y !== last.row);
        const dir = validDirs[Math.floor(Math.random() * validDirs.length)];
        next.col += dir.x;
        next.row += dir.y;
        // Stay in bounds
        next.col = Math.max(0, Math.min(GRID_COLS - 1, next.col));
        next.row = Math.max(0, Math.min(GRID_ROWS - 1, next.row));
      }

      // Move snake body
      for (let i = snake.length - 1; i > 0; i--) {
        snake[i] = {...snake[i - 1]};
      }
      snake[0] = next;
    }

    // --- Random Color Generator ---
    function getRandomColor() {
      // Returns a random hex color string
      return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
    }

    // --- Game Loop ---
    let lastMove = 0;
    app.ticker.add((delta) => {
      const now = performance.now();
      if (now - lastMove > 200) { // Snake moves every 200ms
        moveSnake();
        lastMove = now;
      }
      drawGrid();
      drawBet();
      drawSnake();
      drawCursor();
    });

    // --- Responsive Resize ---
    function resize() {
      const cols = Math.floor(window.innerWidth / BLOCK_SIZE);
      const rows = Math.floor(window.innerHeight / BLOCK_SIZE);
      app.renderer.resize(cols * BLOCK_SIZE, rows * BLOCK_SIZE);
    }
    window.addEventListener('resize', resize);

    // Initial draw
    resize();
    drawGrid();
    drawSnake();
    drawBet();
    drawCursor();
  </script>
</body>
</html>