<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Snake Bet Game (PixiJS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- PixiJS and CRT Filter CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@pixi/filter-crt@5.1.1/dist/filter-crt.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #18181b;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 0 auto;
      box-shadow: 0 0 32px #000a;
      border-radius: 12px;
    }
    #toggleBetMode {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 10;
      padding: 10px 24px;
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(90deg, #6366f1 0%, #06b6d4 100%);
      border: none;
      border-radius: 12px;
      box-shadow: 0 4px 16px #0002;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
    }
    #toggleBetMode:hover {
      background: linear-gradient(90deg, #06b6d4 0%, #6366f1 100%);
      transform: scale(1.05);
    }
    #toggleBetMode:active {
      background: linear-gradient(90deg, #6366f1 0%, #06b6d4 100%);
      transform: scale(0.97);
    }
    #betCountDisplay {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10;
      padding: 10px 24px;
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(90deg, #06b6d4 0%, #6366f1 100%);
      border: none;
      border-radius: 12px;
      box-shadow: 0 4px 16px #0002;
      user-select: none;
      letter-spacing: 1px;
      transition: background 0.2s, transform 0.1s;
    }
  </style>
</head>
<body>
  <button id="toggleBetMode">Multiple Bet: ON</button>
  <div id="betCountDisplay">Bets: 0</div>
  <script>
    // --- Config ---
    const BLOCK_SIZE = 28;
    let GRID_COLS = Math.floor(window.innerWidth / BLOCK_SIZE);
    let GRID_ROWS = Math.floor(window.innerHeight / BLOCK_SIZE);

    // --- PixiJS Setup ---
    const app = new PIXI.Application({
      width: GRID_COLS * BLOCK_SIZE,
      height: GRID_ROWS * BLOCK_SIZE,
      backgroundColor: 0x18181b,
      antialias: false,
      resolution: window.devicePixelRatio || 1,
    });
    document.body.appendChild(app.view);

    // --- CRT Filter ---
    const crtFilter = new PIXI.filters.CRTFilter({
      curvature: 4,
      lineWidth: 2,
      lineContrast: 0.25,
      verticalLine: true,
      noise: 0.1,
      noiseSize: 1,
      vignetting: 0.3,
      vignettingAlpha: 0.6,
      vignettingBlur: 0.3,
      seed: Math.random(),
      time: 0
    });
    app.stage.filters = [crtFilter];

    // --- State ---
    let snake = [{ col: 5, row: 5 }];
    let snakeDir = { x: 1, y: 0 };
    let snakeMovingToBet = false;
    let snakePausedUntil = 0;
    let cursor = { col: 0, row: 0 };
    let betModeMultiple = true;
    let bets = []; // Array of {col, row, color}

    // --- Graphics Containers ---
    const gridGfx = new PIXI.Graphics();
    const snakeGfx = new PIXI.Graphics();
    const betGfx = new PIXI.Container(); // Use Container for bet numbers
    const cursorGfx = new PIXI.Graphics();
    app.stage.addChild(gridGfx, betGfx, snakeGfx, cursorGfx);

    // --- Draw Grid ---
    function drawGrid() {
      gridGfx.clear();
      gridGfx.lineStyle(1, 0xeeeeee, 0.5);
      for (let r = 0; r <= GRID_ROWS; r++) {
        gridGfx.moveTo(0, r * BLOCK_SIZE);
        gridGfx.lineTo(GRID_COLS * BLOCK_SIZE, r * BLOCK_SIZE);
      }
      for (let c = 0; c <= GRID_COLS; c++) {
        gridGfx.moveTo(c * BLOCK_SIZE, 0);
        gridGfx.lineTo(c * BLOCK_SIZE, GRID_ROWS * BLOCK_SIZE);
      }
    }

    // --- Draw Snake ---
    function drawSnake() {
      snakeGfx.clear();
      for (const [i, part] of snake.entries()) {
        snakeGfx.beginFill(0x222326);
        snakeGfx.drawRect(part.col * BLOCK_SIZE, part.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        snakeGfx.endFill();
        // Eyes on head
        if (i === 0) {
          const eyeW = 3, eyeH = 8;
          const offsetX = BLOCK_SIZE / 4;
          const offsetY = BLOCK_SIZE / 3;
          // Left eye
          snakeGfx.beginFill(0xffffff);
          snakeGfx.drawRect(part.col * BLOCK_SIZE + offsetX, part.row * BLOCK_SIZE + offsetY, eyeW, eyeH);
          snakeGfx.endFill();
          // Right eye
          snakeGfx.beginFill(0xffffff);
          snakeGfx.drawRect(part.col * BLOCK_SIZE + BLOCK_SIZE - offsetX - eyeW, part.row * BLOCK_SIZE + offsetY, eyeW, eyeH);
          snakeGfx.endFill();
        }
      }
    }

    // --- Draw Bets ---
    function drawBets() {
      betGfx.removeChildren();
      bets.forEach((bet, idx) => {
        const rect = new PIXI.Graphics();
        rect.beginFill(PIXI.utils.string2hex(bet.color));
        rect.drawRect(bet.col * BLOCK_SIZE, bet.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        rect.endFill();
        betGfx.addChild(rect);

        // Draw bet number
        const style = new PIXI.TextStyle({
          fontSize: BLOCK_SIZE * 0.6,
          fill: '#fff',
          fontWeight: 'bold',
        });
        const numText = new PIXI.Text((idx + 1).toString(), style);
        numText.x = bet.col * BLOCK_SIZE + BLOCK_SIZE / 2 - numText.width / 2;
        numText.y = bet.row * BLOCK_SIZE + BLOCK_SIZE / 2 - numText.height / 2;
        betGfx.addChild(numText);
      });
    }

    // --- Draw Cursor ---
    function drawCursor() {
      cursorGfx.clear();
      cursorGfx.lineStyle(2, 0xffffff, 1);
      cursorGfx.drawRect(cursor.col * BLOCK_SIZE, cursor.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    // --- Mouse Cursor ---
    app.view.addEventListener('mousemove', e => {
      const rect = app.view.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      cursor.col = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(x / BLOCK_SIZE)));
      cursor.row = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(y / BLOCK_SIZE)));
    });

    // --- Place Bet ---
    app.view.addEventListener('click', () => {
      if (betModeMultiple) {
        if (!bets.some(b => b.col === cursor.col && b.row === cursor.row)) {
          bets.push({
            col: cursor.col,
            row: cursor.row,
            color: getRandomColor()
          });
        }
      } else {
        bets = [{
          col: cursor.col,
          row: cursor.row,
          color: getRandomColor()
        }];
      }
      snakeMovingToBet = true;
    });

    // --- Snake Movement ---
    function moveSnake() {
      if (Date.now() < snakePausedUntil) return;
      let head = snake[0];
      let next = { col: head.col, row: head.row };

      if (snakeMovingToBet && bets.length > 0) {
        const bet = bets[0];
        if (head.col < bet.col) next.col++;
        else if (head.col > bet.col) next.col--;
        else if (head.row < bet.row) next.row++;
        else if (head.row > bet.row) next.row--;
        if (next.col === bet.col && next.row === bet.row) {
          const tail = snake[snake.length - 1];
          snake.push({ col: tail.col, row: tail.row });
          bets.shift();
          snakeMovingToBet = bets.length > 0;
          snakePausedUntil = Date.now() + 50;
        }
      } else {
        const dirs = [
          { x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }
        ];
        const last = snake[1] || head;
        let validDirs = dirs.filter(d => head.col + d.x !== last.col || head.row + d.y !== last.row);
        validDirs = validDirs.filter(d => {
          const newCol = head.col + d.x;
          const newRow = head.row + d.y;
          return !snake.some(part => part.col === newCol && part.row === newRow);
        });
        const dir = validDirs.length ? validDirs[Math.floor(Math.random() * validDirs.length)] : { x: 0, y: 0 };
        next.col += dir.x;
        next.row += dir.y;
        next.col = Math.max(0, Math.min(GRID_COLS - 1, next.col));
        next.row = Math.max(0, Math.min(GRID_ROWS - 1, next.row));
      }
      for (let i = snake.length - 1; i > 0; i--) {
        snake[i] = { ...snake[i - 1] };
      }
      snake[0] = next;
    }

    // --- Random Color Generator ---
    function getRandomColor() {
      return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
    }

    // --- Game Loop ---
    let lastMove = 0;
    app.ticker.add((delta) => {
      crtFilter.time += delta * 0.05; // Animate CRT effect
      const now = performance.now();
      let baseSpeed = 200;
      let speed = Math.max(60, baseSpeed - bets.length * 25);
      if (now - lastMove > speed) {
        moveSnake();
        lastMove = now;
      }
      drawGrid();
      drawBets();
      drawSnake();
      drawCursor();
      document.getElementById('betCountDisplay').textContent = 'Bets: ' + bets.length;
    });

    // --- Responsive Resize ---
    function resize() {
      GRID_COLS = Math.floor(window.innerWidth / BLOCK_SIZE);
      GRID_ROWS = Math.floor(window.innerHeight / BLOCK_SIZE);
      app.renderer.resize(GRID_COLS * BLOCK_SIZE, GRID_ROWS * BLOCK_SIZE);
    }
    window.addEventListener('resize', resize);

    // --- Toggle bet mode button ---
    document.getElementById('toggleBetMode').onclick = function () {
      betModeMultiple = !betModeMultiple;
      this.textContent = betModeMultiple ? 'Multiple Bet: ON' : 'Multiple Bet: OFF';
      if (!betModeMultiple && bets.length > 1) {
        bets = bets.length ? [bets[0]] : [];
      }
    };

    // --- Initial draw ---
    resize();
    drawGrid();
    drawSnake();
    drawBets();
    drawCursor();
  </script>
</body>
</html>