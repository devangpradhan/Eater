<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Snake Bet Game (PixiJS)</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #ffffff;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #game {
      display: block;
      margin: 0 auto;
    }

    #toggleBetMode {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 10;
      padding: 10px 24px;
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(90deg, #6366f1 0%, #06b6d4 100%);
      border: none;
      border-radius: 12px;
      box-shadow: 0 4px 16px #0002;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
    }

    #betCountDisplay {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10;
      padding: 10px 24px;
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(90deg, #06b6d4 0%, #6366f1 100%);
      border: none;
      border-radius: 12px;
      box-shadow: 0 4px 16px #0002;
      user-select: none;
      letter-spacing: 1px;
      transition: background 0.2s, transform 0.1s;
    }

    #toggleBetMode:hover {
      background: linear-gradient(90deg, #06b6d4 0%, #6366f1 100%);
      transform: scale(1.05);
    }

    #toggleBetMode:active {
      background: linear-gradient(90deg, #6366f1 0%, #06b6d4 100%);
      transform: scale(0.97);
    }
  </style>
</head>

<body>
  <button id="toggleBetMode"
    style="position:fixed;top:16px;right:16px;z-index:10;padding:8px 16px;font-size:16px;">Multiple Bet: ON</button>
  <div id="betCountDisplay"
    style="position:fixed;top:16px;left:16px;z-index:10;padding:8px 16px;font-size:16px;background:#fff;color:#000;border-radius:8px;box-shadow:0 2px 8px #0002;">
    Eaten Bets: 0</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@pixi/filter-glitch@4.2.2/dist/filter-glitch.min.js"></script>
  <script>
    // --- Config ---
    const BLOCK_SIZE = 28;
    const GRID_COLS = Math.floor(window.innerWidth / BLOCK_SIZE);
    const GRID_ROWS = Math.floor(window.innerHeight / BLOCK_SIZE);

    // --- PixiJS Setup ---
    const app = new PIXI.Application({
      width: GRID_COLS * BLOCK_SIZE,
      height: GRID_ROWS * BLOCK_SIZE,
      backgroundColor: 0xffffff,
      antialias: false,
      resolution: window.devicePixelRatio || 1,
    });
    document.body.appendChild(app.view);

    // --- State ---
    let snake = [{ col: 5, row: 5 }]; // Snake body: head is first element
    let snakeDir = { x: 1, y: 0 };
    let snakeMovingToBet = false;
    let snakePausedUntil = 0;
    let cursor = { col: 0, row: 0 };
    let betModeMultiple = true;
    let bets = []; // Array of {col, row, color}
    let eatenBetsCount = 0; // Track the number of eaten bets

    // --- Graphics Containers ---
    const gridGfx = new PIXI.Graphics();
    const snakeGfx = new PIXI.Graphics();
    const betGfx = new PIXI.Graphics();
    const cursorGfx = new PIXI.Graphics();

    // Add graphics directly to the stage
    app.stage.addChild(gridGfx, betGfx, snakeGfx, cursorGfx);

    // --- Draw Grid ---
    function drawGrid() {
      gridGfx.clear();
      gridGfx.lineStyle(1, 0xeeeeee, 0.5);

      // Draw horizontal lines
      for (let r = 0; r <= GRID_ROWS; r++) {
        gridGfx.moveTo(0, r * BLOCK_SIZE);
        gridGfx.lineTo(GRID_COLS * BLOCK_SIZE, r * BLOCK_SIZE);
      }

      // Draw vertical lines
      for (let c = 0; c <= GRID_COLS; c++) {
        gridGfx.moveTo(c * BLOCK_SIZE, 0);
        gridGfx.lineTo(c * BLOCK_SIZE, GRID_ROWS * BLOCK_SIZE);
      }
    }

    // --- Draw Snake ---
    function drawSnake() {
      snakeGfx.clear();
      for (const [i, part] of snake.entries()) {
        // Head: dark gray, Body: gray
        snakeGfx.beginFill(0x222326); // Head and body: dark gray
        snakeGfx.drawRect(part.col * BLOCK_SIZE, part.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        snakeGfx.endFill();
        // Draw vertical ':' eyes on head
        if (i === 0) {
          const eyeW = 3, eyeH = 8;
          const offsetX = BLOCK_SIZE / 4;
          const offsetY = BLOCK_SIZE / 3;
          // Left eye
          snakeGfx.beginFill(0xffffff);
          snakeGfx.drawRect(part.col * BLOCK_SIZE + offsetX, part.row * BLOCK_SIZE + offsetY, eyeW, eyeH);
          snakeGfx.endFill();
          // Right eye
          snakeGfx.beginFill(0xffffff);
          snakeGfx.drawRect(part.col * BLOCK_SIZE + BLOCK_SIZE - offsetX - eyeW, part.row * BLOCK_SIZE + offsetY, eyeW, eyeH);
          snakeGfx.endFill();
        }
      }
    }

    // --- Draw Bets ---
    function drawBets() {
      betGfx.clear();
      bets.forEach((bet) => {
        betGfx.beginFill(PIXI.utils.string2hex(bet.color));
        betGfx.drawRect(bet.col * BLOCK_SIZE, bet.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        betGfx.endFill();
      });
    }

    // --- Draw Cursor ---
    function drawCursor() {
      cursorGfx.clear();
      cursorGfx.lineStyle(2, 0xffffff, 1);
      cursorGfx.drawRect(cursor.col * BLOCK_SIZE, cursor.row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    // --- Mouse Cursor ---
    app.view.addEventListener('mousemove', e => {
      const rect = app.view.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      cursor.col = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(x / BLOCK_SIZE)));
      cursor.row = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(y / BLOCK_SIZE)));
    });

    // --- Place Bet ---
    app.view.addEventListener('click', () => {
      if (betModeMultiple) {
        // Add bet if not already present at this cell
        if (!bets.some(b => b.col === cursor.col && b.row === cursor.row)) {
          bets.push({
            col: cursor.col,
            row: cursor.row,
            color: getRandomColor()
          });
        }
      } else {
        bets = [{
          col: cursor.col,
          row: cursor.row,
          color: getRandomColor()
        }];
      }
      snakeMovingToBet = true;
    });

    // --- Snake Movement ---
    function moveSnake() {
      if (Date.now() < snakePausedUntil) return; // Pause after eating

      let head = snake[0];
      let next = { col: head.col, row: head.row };

      if (snakeMovingToBet && bets.length > 0) {
        // Move towards first bet in sequence
        const bet = bets[0];
        if (head.col < bet.col) next.col++;
        else if (head.col > bet.col) next.col--;
        else if (head.row < bet.row) next.row++;
        else if (head.row > bet.row) next.row--;
        // If reached bet
        if (next.col === bet.col && next.row === bet.row) {
          // Grow snake by adding a new segment at the tail
          const tail = snake[snake.length - 1];
          snake.push({ col: tail.col, row: tail.row });
          bets.shift(); // Remove eaten bet
          eatenBetsCount++; // Increment eaten bets count
          snakeMovingToBet = bets.length > 0;
          snakePausedUntil = Date.now() + 50; // Pause 0.5s
        }
      } else {
        // Random roam (no reverse, no self-collision)
        const dirs = [
          { x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }
        ];
        // Prevent reversing into itself
        const last = snake[1] || head;
        let validDirs = dirs.filter(d => head.col + d.x !== last.col || head.row + d.y !== last.row);
        // Prevent moving into own body
        validDirs = validDirs.filter(d => {
          const newCol = head.col + d.x;
          const newRow = head.row + d.y;
          return !snake.some(part => part.col === newCol && part.row === newRow);
        });
        // If no valid dirs, stay in place
        const dir = validDirs.length ? validDirs[Math.floor(Math.random() * validDirs.length)] : { x: 0, y: 0 };
        next.col += dir.x;
        next.row += dir.y;
        // Stay in bounds
        next.col = Math.max(0, Math.min(GRID_COLS - 1, next.col));
        next.row = Math.max(0, Math.min(GRID_ROWS - 1, next.row));
      }

      // Move snake body
      for (let i = snake.length - 1; i > 0; i--) {
        snake[i] = { ...snake[i - 1] };
      }
      snake[0] = next;
    }

    // --- Random Color Generator ---
    function getRandomColor() {
      // Returns a random hex color string
      return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
    }

    // --- Game Loop ---
    let lastMove = 0;
    app.ticker.add((delta) => {
      const now = performance.now();
      // Snake speed increases with bet count (min 60ms, max 200ms)
      let baseSpeed = 200;
      let speed = Math.max(60, baseSpeed - bets.length * 25);
      if (now - lastMove > speed) {
        moveSnake();
        lastMove = now;
      }
      drawGrid();
      drawBets();
      drawSnake();
      drawCursor();
      // Update eaten bet count display
      document.getElementById('betCountDisplay').textContent = 'Eaten Bets: ' + eatenBetsCount;
    });

    // --- Responsive Resize ---
    function resize() {
      const cols = Math.floor(window.innerWidth / BLOCK_SIZE);
      const rows = Math.floor(window.innerHeight / BLOCK_SIZE);
      app.renderer.resize(cols * BLOCK_SIZE, rows * BLOCK_SIZE);
    }
    window.addEventListener('resize', resize);

    // Toggle bet mode button
    document.getElementById('toggleBetMode').onclick = function () {
      betModeMultiple = !betModeMultiple;
      this.textContent = betModeMultiple ? 'Multiple Bet: ON' : 'Multiple Bet: OFF';
      if (!betModeMultiple && bets.length > 1) {
        bets = bets.length ? [bets[0]] : [];
      }
    };

    // Initial draw
    resize();
    drawGrid();
    drawSnake();
    drawBets();
    drawCursor();
  </script>
</body>

</html>